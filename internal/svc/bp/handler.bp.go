package bp

import "text/template"

var handlerTemplate = `// AUTOGENERATED CODE.
// !!  DO NOT EDIT  !!

package {{ .Pkg }}http

import (
	"context"
	"encoding/json"
	"fmt"
	"{{ .PkgPath }}"
	httptransport "github.com/go-kit/kit/transport/http"
	"net/http"
)

type handler struct {
}

func (h handler) Handle(ctx context.Context, err error) {
	fmt.Printf("from the error handler: %#v\n", err)
}

func RegisterHandlers(h *http.ServeMux, s {{ .Pkg }}.{{ .ServiceName }}, namespace string) {
	options := []httptransport.ServerOption{
		httptransport.ServerErrorEncoder(encodeError),
		httptransport.ServerErrorHandler(handler{}),
	}
	{{ range $func := .Funcs }}
	get{{ .Name }}Endpoint := make{{ .Name }}Endpoint(s)
	//for _, mw := range mws {
	//	getSomethingEndpoint = mw(getSomethingEndpoint)
	//}
	get{{ .Name }}Handler := httptransport.NewServer(
		get{{ .Name }}Endpoint,
		decode{{ .Name }}Request,
		encode{{ .Name }}Response,
		options...,
	)
	h.Handle(namespace+"/{{ .Name }}", get{{ .Name }}Handler)
	{{ end }}

	h.Handle(namespace+"/_docs", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		var eps []map[string]string
		eps = append(eps, map[string]string{"name": "getsomething", "params": "id string, arg someservice.SomeArgumentType"})
		resp := map[string]any{"services": eps}
		if err := json.NewEncoder(w).Encode(resp); err != nil {
			fmt.Fprintf(w, "{%q:%q}", "error", err)
		}
	}))
}
`

func NewHandlerTemplate(serviceName string) *template.Template {
	t := template.New(serviceName)
	return template.Must(t.Parse(handlerTemplate))
}
